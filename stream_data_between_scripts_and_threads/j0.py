import datetime, random, time #os, sys
import threading
from queue import Queue

#Import third party function in j3.py
from j3 import max_function as maximum

#Import functions from other scripts, so that, by sharing this reference, j0.py
#can delegate data treatments to other scripts j1.py and j2.py
from j1 import stream_data_from_j0 as j1_treatment
from j2 import stream_data_from_j0 as j2_treatment

#Frequency of data to be treated
data_fequency = 1           #In seconds
script_run_duration = 5    #In seconds
data = 0

#The output of this main script will be a variable that, when modified, 
#returns a value
class output_value:
    def __init__(self, args = [0, 0], max_value = 0):
        self._args = [0, 0]
        self._max_value = 0
        
    def get_args(self):
        return self._args
    
    def get_max_value(self):
        return self._max_value
    
    def set_args(self, updated_arg, updated_arg_rank):
        self._args[updated_arg_rank] = updated_arg
        self._max_value = maximum(self._args)
        print('Output value :', self._max_value)
        print(datetime.datetime.now())
        print('')
        return self._max_value

#Create an instance of this output class defined just before
my_output = output_value()

#Instantiation of a queue to exchange data between threads
queue_to_tread_1 = Queue()

#Instantiation of a lock to have threads ordered properly before averaging
my_lock = threading.Lock()

#Launch a thread that will produce some data to be treated by other threads.
#Note that instead of producing it's own data for the example, it's purpose
#would be to read some data before 'sending' them to scripts
def data_generator_func():
    #We say to the function that 'data' is global and modifiable by the function
    global data
    j = 0
    while j < script_run_duration / data_fequency: #Lasts for script_run_duration
        my_lock.acquire()
        #Randomly send data to j1.py o j2.py so those data are treated there
        data = random.randint(1, 101)
        print('Data generation - random integer in [1, 100] : ', data)
        print(datetime.datetime.now())
        print('')
        j += 1
        queue_to_tread_1.put(data)
        my_lock.release()
        time.sleep(data_fequency)
    #return data

data_generator_thread = threading.Thread(target = data_generator_func)
data_generator_thread.start()


#Launch treads corresponding to j1.py and j2.py scripts treating data
#j1.py will treat data yielded from the data_generator_func, and j2.py will
#generate it's own data at it's own rythm
def thread_j1_func(queue_in):
    while True:
        #'Send' the data to j1.py so it's treated there and update my_output
        if not queue_in.empty():
            my_lock.acquire()
            print("j1 file's thread : j1 takes generated data as input and multiply it by 3 immediately")
            print(datetime.datetime.now())
            print('')
            data_val = queue_in.get()
            my_output.set_args(j1_treatment(data_val), 0)
            my_lock.release()
    #return 'Data treated by j1.py \n' + str(j1_treatment(data_val)) + '\n'

def thread_j2_func():
    for letter in j2_treatment():
        my_lock.acquire()
        #Get the data generated then yielded by j2.py and update my_output
        print("j2 file's thread : j2 returns 0 or 1000 randomly every N seconds")
        print(datetime.datetime.now())
        print('')
        my_output.set_args(letter, 1)
        my_lock.release()
    #return 'Data generated by j2.py \n' + str(letter) + '\n'

thread_j1 = threading.Thread(target = thread_j1_func, args = (queue_to_tread_1,))
thread_j2 = threading.Thread(target = thread_j2_func)

thread_j1.start()
thread_j2.start()



